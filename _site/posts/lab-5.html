<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CS161 Labs - Lab 5: Applicative Reverse Polish Notation Calculator</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">CS161 Labs</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Lab 5: Applicative Reverse Polish Notation Calculator</h1>

            <div class="info">
    Posted on November  2, 2015
    
</div>

<h1 id="announcements">Announcements</h1>
<p>Office hours 1-2pm on Wednesday and Thursday. For the quarter you can take two 24-hour extensions.</p>
<h1 id="submission-guidelines">Submission Guidelines</h1>
<p>In today’s <a href="http://cmsc-16100.cs.uchicago.edu/2015/Lectures/lecture-19.php">class notes</a> applicative parsers are covered loosely based on the classic <a href="http://people.cs.uu.nl/jeroen/article/parsers/parsers.ps">Functional Parsers</a> article by Joroen Fokker. The goal here is to use these ideas to build a reverse polish notation calculator.</p>
<p>Some code to get you started is available on <a href="../fls/Lab5.hs">Lab5.hs</a>. The task is to use this code to implement a reverse polish notation calculator that supports <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, <code>^</code>, <code>!</code>, and <code>|</code>. Here <code>/</code> will be <code>div</code> and <code>%</code> is <code>mod</code>. Your parser should accept arbitrary ASCII strings and throw an error <code>No Parse</code> if the string cannot be computed using a reverse polish notation calculator. The accepted inputs are numbers and operators. Note that <code>34 52 %</code> would be <code>mod 34 52</code> and <code>3823 323 /</code> is <code>div 3823 323</code>.</p>
<p>Exponentiation is <code>^</code> and corresponds to the Haskell operator <code>^</code>. <code>!</code> is the factorial function (defined only on the non-negative integers). The unary <code>|</code> takes the absolute value of the input. You should also be able to handle negative numbers which are entered in as <code>(-99)</code> as well as positive numbers <code>(8)</code>. You do not need to handle nesting of parentheses.</p>
<p>In your <code>lab5/</code> folder of your repository you should have three files (with names exactly matching–including case):</p>
<ol style="list-style-type: decimal">
<li><code>Lab5.hs</code> which should include a module <code>Lab5</code></li>
<li><code>Main.hs</code> which will import functions from <code>Lab5</code> to implement a REPL (read-eval-print-loop) executable reverse polish notation calculator. The calculator should be implemented using functional parsers.</li>
<li><code>Tests.hs</code> a file of tests. In this lab we will have 100% test coverage so write one test per function in <code>Lab5.hs</code> (and not just the functions that you implement, this includes the ones already in the file). This should also be an executable so that if we compile it and run <code>./Test</code> we get a print out of the number of passing tests.</li>
</ol>
<p>The REPL implemented in <code>Main.hs</code> should be such that if we call <code>./Main</code> then it will present to stdout a session which would allow the following interaction:</p>
<pre class="shell"><code>&gt; 3 4 +
7
&gt; +
No Parse
&gt;   10   3 ( - 80) 9 / + 5 - *
60</code></pre>
<p>so that there is a <code>&gt;</code> before the are to input the commands and the output is relayed below.</p>
<h1 id="functional-parsing-with-applicative">Functional Parsing with Applicative</h1>
<p>The distinction between this calculator and previous calculators is that you wil be specifically checking for well-formed input. You are allowed to use Haskell’s internal arithmetic to perform the computations, but you will have to implement a <em>grammar</em> to recognize which inputs are valid and which are invalid.</p>
<p>The details for implementing the REPL are up to you provided that they produce the desired behavior (and the logic for the REPL should all go into <code>Main.hs</code>). The calculator library you build will be in the file <code>Lab5.hs</code>.</p>
<p>When dealing with well-formed inputs a good starting point is to think of a calculator as a function <code>eval :: String -&gt; Int</code>. Then you can export <code>eval</code> from your <code>Lab5</code> module and use it within <code>Main.hs</code>. However, in our case the parser may fail so it might make more sense to have <code>eval :: String -&gt; Int</code>.</p>
<p>But, taking a step back, this may not be the right function either. In particular, a calculator is actually a bunch of parsing problems rolled into one. At the bottom level we need to parse the operators <code>+</code>, <code>!</code>, etc. and we need to parse numbers <code>238</code>, <code>(-04)</code>, etc. These are related parsing problems and a parser for calculators could plausibly be constructed from a number parser <code>number</code> and an operator parser <code>operator</code> e.g. <code>number &lt;*&gt; operator</code> (or some other gluing mechanism). The advantage of taking the compositional view is that we can treat the number problem separately from the operator problem so that our code becomes more modular. Take this lab for instance, my suggestion is you first build a parser for single digits, e.g. just the numbers <code>[0..9]</code> then handle all positive integers <code>[0..]</code> and then generalize to negative numbers <code>(-38)</code>, <code>( - 6 )</code>, etc. By taking the compositional approach you can incrementally update your <code>number</code> implementation without having to rewrite the <code>operator</code> parser. This makes testing the functions easier as well. But, operators are functions and numbers are numbers so a parser should be something like <code>String -&gt; s</code>.</p>
<p>We’re composing multiple parsers which means that each subparser (e.g. <code>number</code> or <code>operator</code>) will only be responsible for a small part of the string. This means that we want to keep track of how far along in the string we are in our parsing problem. So we might image that we pass the string <code>&quot;32 + 3 ...&quot;</code> to our <code>number</code> parser then it should get us the number <code>32</code> and the remaining string to be parsed <code>&quot; + 3 ...&quot;</code> then a <code>space</code> parser can be applied, then an <code>operator</code> parser, etc. So our function should return both the subparser output and the remaining string to be parsed. Our parser is now of the form <code>String -&gt; (String, s)</code>.</p>
<p>But, there is another problem. We cannot assume that the user passes us a well-formed input, and we want to be robust to all possible inputs. And a substantial fraction of strings of length <code>n</code> are ill formed: e.g. <code>&quot;j &amp;# h4hsji32 3--3 9293 -&quot;</code> so in these cases the calculator should figure out that this is not a valid string and return nothing. In Haskell a convenient way to represent nothing is the empty list <code>[]</code>, since this also allows for the possibility of returning multiple solutions. So our parser type is</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parser</span> result <span class="fu">=</span> <span class="dt">Parser</span> {<span class="ot"> runParser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, result)] }</code></pre>
<p>So a parser for us has two things: (1) the constructor <code>Parser</code> and (2) a function <code>String -&gt; [(String, result)]</code>. The virtue of multiple solutions is that it will make composing intermediate parsers (<code>number</code>, <code>operator</code>, etc.) easier.</p>
<p>We are using record syntax here so given a parser <code>p :: Parser r</code> we access the function with <code>runParser p</code>. For example, the simplest parser is <code>failure</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">failure ::</span> <span class="dt">Parser</span> r
failure <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> const []</code></pre>
<p>this parser always outputs an empty list no matter what the input string is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> runParser failure <span class="fu">$</span> reverse <span class="st">&quot; 3 4 + &quot;</span>
[]</code></pre>
<p>In the above example we are trying to parse the expression <code>&quot; 3 4 +&quot;</code> (the use of <code>reverse</code> here is a hint to think about) and the parser always fails (hence the name). However, it has all the basic details of a parser.</p>
<h2 id="building-a-nonnegative-number-parser">Building a nonnegative number parser</h2>
<p>The code that I’ve provided defines a <code>number</code> parser which can handle non-negative integers:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">number ::</span> <span class="dt">Parser</span> [<span class="dt">Char</span>]
number <span class="fu">=</span> (fmap (<span class="fu">:</span>) digit) <span class="fu">&lt;*&gt;</span> (number <span class="fu">&lt;|&gt;</span> succeed [])</code></pre>
<p>Its ok if it does not make a great deal of sense now, but the goal of this section of the notes is to help you understand what is going on in that code.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
