<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CS161 Labs - Lab 2: Intersections and Computational Geometry</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">CS161 Labs</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Lab 2: Intersections and Computational Geometry</h1>

            <div class="info">
    Posted on October 13, 2014
    
</div>

<h1 id="special-note">Special Note</h1>
<p>This is an extra-credit lab. The lab due this week is last week’s lab.</p>
<h1 id="using-haskell-as-a-model-for-computational-geometry">Using Haskell as a model for Computational Geometry</h1>
<p>The basic idea here is to use Haskell’s algebraic data types as a basis for defining geometric objects. Analytic geometry can then be used to answer geometric questions. In this lab we will model shapes in the two-dimensional plane and answer questions about intersection. This is useful for thinking about the code underlying computer games.</p>
<h2 id="basic-definitions">Basic Definitions</h2>
<p>We begin the lab with some simple definitions</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- A point is a point in the xy plane, represented by x and y coordinates</span>
<span class="co">-- E.g. (Point 0.0 0.0) is the origin, (Point (-1) (1)) is in the top left</span>
<span class="co">-- quadrant.</span>
<span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> <span class="dt">Double</span> <span class="dt">Double</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="co">-- A line segment is a straight line of finite length, defined by its</span>
<span class="co">-- two end points.   E.g. (LineSegment (Point 0 0) (Point 1 1)) is a</span>
<span class="co">-- line segment from the origin to the coordinate (1, 1)</span>
<span class="kw">data</span> <span class="dt">LineSegment</span> <span class="fu">=</span> <span class="dt">LineSegment</span> <span class="dt">Point</span> <span class="dt">Point</span> 
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)


<span class="co">-- A Path is a 2D path in the xy-plane.  The idea is that Path can be </span>
<span class="co">-- extended to support straight lines, curves, and arbitrary paths, </span>
<span class="co">-- but currently there is only one data constructor for Path: Line.</span>
<span class="kw">data</span> <span class="dt">Path</span> <span class="fu">=</span> 
<span class="co">-- Line represents an infinite straight line defined by its slope a</span>
<span class="co">-- and its y intercept b, ie. by the equation y = ax + b</span>
    <span class="dt">Line</span> <span class="dt">Double</span> <span class="dt">Double</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre>
<p>So we now have some basic data structures. LineSegments are constructed from points and we have an abstract notion of a path formed from a line. Throughout this lab we are going to expand the definition of <code>Path</code> to include more definitions and we will write functions that use path using Haskell’s pattern-matching facilities to get the definition right (NOTE: when writing a function that maps a <code>Path</code> to something else use pattern matching idioms).</p>
<ol style="list-style-type: decimal">
<li>Write a function <code>intersects</code> that checks whether a <code>LineSegment</code> intersects with a <code>Line</code>. Try solving for the problem in the case where the line segment is vertical and then see if you can generalize from that.</li>
</ol>
<p>This first problem is meant as a warm-up to start checking intersections. We will add to the definition of <code>intersect</code> as we expand the definition of <code>Path</code>.</p>
<h2 id="defining-data-types-for-shapes">Defining data types for shapes</h2>
<p>A crucial skill is being able to define abstract type definitions to capture real-world objects. We are wanting to do computational geometry so you will need to define models of shapes.</p>
<ol start="2" style="list-style-type: decimal">
<li>Define a type <code>Shape</code> that can be a <code>Triangle</code>, <code>Quadrilateral</code>, or a <code>Circle</code>. Use algebraic datatypes. Make sure that you can check equality and use <code>Show</code>.</li>
</ol>
<h2 id="bounding-boxes-for-shapes">Bounding Boxes for Shapes</h2>
<p>For any shape there is a unique <em>minimum</em> <em>bounding</em> <em>rectangle</em> which is defined as the smallest axis-aligned rectangle that encloses the shape. Axis-aligned here means that each of the four edges of the rectable runs parallel to either the <span class="math"><em>x</em></span>-axis or the <span class="math"><em>y</em></span>-axis. Minimum bounding rectangles are very useful for programming computer games because testing for intersections in general is a very hard problem.</p>
<ol start="3" style="list-style-type: decimal">
<li><p>Write a datatype for <code>BoundingBox</code>. You may choose how you want to do it, but I suggest defining it by two points: the bottom left corner and the upper-right corner.</p></li>
<li><p>Write a function <code>boundShape</code> which maps a <code>Shape</code> to a <code>BoundingBox</code> that maps a shape to its minimum bounding rectangle. Functions such as <code>min</code>, <code>minimum</code>, <code>max</code>, <code>maximum</code> may be useful here.</p></li>
<li><p>Write some tests to ensure that your code works.</p></li>
</ol>
<h2 id="checking-if-lines-intersect-with-bounding-boxes">Checking if Lines Intersect with bounding boxes</h2>
<ol start="6" style="list-style-type: decimal">
<li><p>Implement a function <code>intersectsBB</code> that, given a <code>BoundingBox</code> and a <code>Path</code> checks to see if the path intersects the bounding box. At present this only includes a <code>Line</code></p></li>
<li><p>Write a function <code>mightIntersectShape</code> which use the functions already present to check if a path intersects the bounding box of a shape. This should be a short function without much innovation to it.</p></li>
<li><p>Extend Path to include a type constructor <code>Parabola</code> and add onto <code>intersects</code> and <code>intersectsBB</code>.</p></li>
</ol>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
