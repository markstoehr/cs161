<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CS161 Labs - Lab 4: Haskell Calculator</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">CS161 Labs</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Lab 4: Haskell Calculator</h1>

            <div class="info">
    Posted on October 27, 2014
    
</div>

<h1 id="notes-on-recursion">Notes on Recursion</h1>
<p>Recursive solutions to a problem begin by solving a trivial <em>base case</em> and then solving the <em>recursion step</em>. Take, for instance, summation over a list. The <em>base case</em> is</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">listSum [] <span class="fu">=</span> <span class="dv">0</span></code></pre>
<p>and the <em>recursion step</em> is</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">listSum (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> (listSum xs)</code></pre>
<p>which takes a problem and reduces it to one or more simpler cases of the problem. In the case of list-sum the simpler case is a summation over the tail of a list.</p>
<h1 id="building-a-simple-haskell-calculator">Building a Simple Haskell Calculator</h1>
<p>Later in the course you will consider monadic parsing but in this lab we will focus on the simple parsing problem of constructing a calculator.</p>
<p>The calculator should work as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>
<span class="dv">2</span>
<span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">*</span> <span class="dv">6</span>
<span class="dv">12</span>
<span class="fu">&gt;</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">*</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">1</span>)
<span class="dv">24</span>
<span class="fu">&gt;</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">*</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">6</span>)
<span class="dv">15</span>
<span class="fu">&gt;</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> ((<span class="dv">4</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">*</span> <span class="dv">6</span>)))
<span class="dv">39</span>
<span class="fu">&gt;</span> <span class="dv">5</span> <span class="fu">+-</span><span class="dv">6</span>    <span class="co">--This should be parsed as 5 + (-6)</span>
<span class="fu">-</span><span class="dv">1</span></code></pre>
<p>where user-input is indicated by a prepended <code>&gt;</code>. The lab consists of:</p>
<ul>
<li>Create a data type <code>ArithExpr</code> to represent an expression</li>
<li>Implement a function <code>eval</code> to evaluate the expression to a number</li>
<li>Implement a fuction <code>simpleParseExpr</code> to parse a string into an expression</li>
<li>Use the functions above to read user input and using <code>fmap</code> parse the string into an integer and return the result</li>
</ul>
<h2 id="defining-the-arithexpr-data-type">Defining the <code>ArithExpr</code> Data Type</h2>
<p>This data type should represent</p>
<ul>
<li>a constructor <code>Number</code> for positive or negative integers</li>
<li>Addition and Multiplication operators represented by the constructors <code>Plus</code> and <code>Mult</code>. These operators are most easily defined as a data constructor taking two arguments.</li>
</ul>
<h2 id="evaluating-arithexpr">Evaluating <code>ArithExpr</code></h2>
<p>Write a function <code>eval</code> which evaluates an <code>ArithExpr</code> and outputs a number:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> eval (<span class="dt">Mult</span> (<span class="dt">Plus</span> (<span class="dt">Number</span> <span class="dv">2</span>) (<span class="dt">Number</span> <span class="dv">3</span>)) (<span class="dt">Plus</span> (<span class="dt">Number</span> <span class="dv">3</span>) (<span class="dt">Number</span> <span class="dv">2</span>)))
<span class="dv">25</span> </code></pre>
<p>Recursion is your main tool here.</p>
<h2 id="parsing-an-arithexpr-from-a-string">Parsing an <code>ArithExpr</code> from a string</h2>
<p>The input will be whitespace, <code>*</code>, <code>+</code>, or digits <code>[0-9]</code>. To parse the input the following steps are recommended:</p>
<ol style="list-style-type: decimal">
<li>Remove whitespace using <code>isSpace</code> from <code>Data.Char</code>.</li>
<li>Tokenize: break up the expression into tokens where each token is an integer (positive or negative), a plus, or a times. You will likely want to perform this operation recursively. The functions <code>dropWhile</code>, <code>takeWhile</code>, and <code>span</code> in <code>Data.List</code> will probably be helpful. <code>Data.Char</code> has <code>isDigit</code> which can also be helpful. These tokens will be in a list</li>
<li>Turn the tokens into an <code>ArithExpr</code>. Here <code>read</code> is useful when applied to integers. Thinking about arithmetic it makes sense to split the list at the operator of least precedence and then recurse on the elements.</li>
</ol>
<h3 id="tokens-to-arithexpr">Tokens to <code>ArithExpr</code></h3>
<p>Expanding on the third step a little more: think about the expression <code>4*3+4</code> which should be broken up into <code>4*3</code>, <code>+</code>, <code>4</code>. The function <code>break</code> will be useful for this. I called my function that does this <code>buildExpr</code> and in the above example <code>buildExpr</code> would be recursively applied so you would get <code>buildExpr ['4','*','3']</code>. Use</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">error <span class="st">&quot;Informative Error Message&quot;</span></code></pre>
<p>as the result of functions that end up with a parsing error (i.e. an ill-formed input). The error message should be replaced with something informative.</p>
<h2 id="user-input">User Input</h2>
<p>User input can be very simple: prompt the user to input a string, take that string, apply <code>simpleParseExpr</code> to the string, and then output the result. There’s a wrinkle that is added by the presence of IO. The hint is to take a standard program for reading in a string and outputing the text. Consider <code>getLine</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t getLine
getLine<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></code></pre>
<p>so <code>getLine</code> has type <code>IO String</code>. <code>simpleParseExpr</code> will have type signature <code>String -&gt; Int</code> so it cannot naively be used.<br />To use <code>simpleParseExpr</code> in a <code>do</code> block you will most likely want to use <code>fmap</code> and <code>show</code> (think about the exposition on types and functors in class).<br />Think carefully about the type signatures. Open up a <code>ghci</code> session and you’ll see:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t show
show<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t fmap
fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>To use <code>fmap</code> you have to pick a type for three type variables: <code>f</code>, <code>a</code>, and <code>b</code>. Think about what <code>f</code> is going to be in an <code>IO</code> context. Think about the other type variables. What is the function <code>a -&gt; b</code> going to be? The solution should be not add to the line count of a simple program that prompts the user for an input string and then prints the string out.</p>
<h2 id="extra-credit">Extra-Credit</h2>
<p>Add support for parentheses. They should be used in the normal way: in that they should form a separate <code>buildExpr</code> token that get parsed separately from the rest of the expression. The rules for parentheses are important here.</p>
<h1 id="what-to-turn-in">What to turn in</h1>
<p>The work should be saved to a <code>lab4</code> folder and there should be a file <code>lab4.hs</code> which, when run, should prompt the user for input and then parse the arithmetic expression. The stated data structures and functions in the exposition above should be included in <code>lab4.hs</code>.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
