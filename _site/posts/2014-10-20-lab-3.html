<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CS161 Labs - Lab 3: Breaking Ciphers</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">CS161 Labs</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Lab 3: Breaking Ciphers</h1>

            <div class="info">
    Posted on October 20, 2014
    
</div>

<h1 id="introduction">Introduction</h1>
<p>In lecture you have written a couple of basic programs for encrypting text. In this lab we will break those ciphers and crack the codes.</p>
<p>The message before encoding will be denoted as the “plaintext” and the encrypted message will be denoted as the “ciphertext”. Encryption is simple a function from plaintext messages to ciphertext messages. In this lab you will invert an unknown encryption function to get the plaintext given only the ciphertext.</p>
<h1 id="dictionary-based-attacks">Dictionary-Based Attacks</h1>
<p>The first class of attacks we will consider will be dictionary-based.</p>
<h2 id="a-key-assumption">A Key Assumption</h2>
<p>The basic hypothesis underlying such an attack is that the plaintext will mostly only have words from a known dictionary (in our case this is the file <code>/usr/share/dict/words</code>) on the Linux machines. Given that assumption it is your task to construct attacks which successfully decrypt the messages written up in this lab.</p>
<p>We exclude special characters other than spaces and spaces will not be encrypted. The special characters in some cases will remain in the ciphertext but our encryption algorithm will ignore them. Not all of the words will be in the dictionary, but most will.</p>
<p>For each ciphertext we give you to decrypt we will let you know the set of ciphers that were potentially used to encrypt it.</p>
<h2 id="breaking-rot-n">Breaking ROT-<code>n</code></h2>
<p>In class the <code>rot-n</code> code was introduced. In this part of the lab your goal is to break this and decode the file <a href="../fls/c1.txt">c1.txt</a>. Given a ciphertext infer what the <code>n</code> is.</p>
<p>A function that will be useful for cracking the code is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hamming ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre>
<p>which is a function to measure the “distance” between two strings based on how many characters they share. You will also want to make use of the word list mentioned earlier.</p>
<p>Implement this section as a program</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">./derot</span> [file containing ciphertext]</code></pre>
<p>where <code>derot</code> prints to standard output</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">n=</span>[<span class="kw">rotation</span> factor]
[<span class="kw">plaintext</span>]</code></pre>
<p>I will provide a ciphertext to decode, <code>c1.txt</code> among the lab files. It is highly recommended that you create your own plaintexts, encode them using the <code>rot</code> program from class and then see if you can decode them.</p>
<h2 id="breaking-a-vigenère-cipher-of-known-password-length">Breaking a Vigenère Cipher of known password length</h2>
<p>This is essentially a generalization of the Caesar rotation cipher. This cipher is contained in <a href="../fls/c2.txt">c2.txt</a> and the password used is of length 15. This means that you have 15 rotation ciphers running simultaneously so if <code>s</code> is your ciphertext then <code>s !! 0</code>, <code>s !! 15</code>, <code>s !! 32</code>, etc. all have the same rotation cipher. The same is true for <code>s !! 1</code>, <code>s !! 17</code>, etc.</p>
<p>Write a bash tool</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">./vindecoden</span> [ciphertext file] [N]</code></pre>
<p>which takes a ciphertext file and a length then outputs the plaintext and the password.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">password=</span>[<span class="kw">estimated</span> password]
[<span class="kw">plaintext</span>]</code></pre>
<p>For this problem all of the letters are upper case, the spaces are not encoded and ignored by the encryption, also, there are no special characters: just <code>[A-Z]</code>. Again, write your own Vigenère encryption and produce a test ciphertext to make sure that your code works before embarking on the more challenging lab assignment of <code>c2.txt</code>.</p>
<p>You may also assume that the password comes from words in dictionary (recalling that everything is upper case). Use that fact in your code.</p>
<h2 id="using-trees-for-n-gram-counts">Using Trees for N-gram counts</h2>
<p>In order to crack this code it is very likely you will make use of n-gram counts. An letter n-gram count is the number of times a particular sequence of characters occurs in a text. Consider the letter bigram <code>VVV</code> which does not occur in any English word but <code>ORM</code> does.<br />One may which to check how many of the letter n-grams in a candidate decoding of the ciphertext actually occur in the dictionary: i.e. do the ciphertext letter n-gram statistics match the dictionary letter n-gram statistics? This is generally a very hard question to work on but its made easier by the fact that the letter n-grams which occur in English are sparse and highly concentrated. That is, most letter n-grams never occur in English so this can be a big tip off that a particular decoding sequence is not possible.</p>
<p>To use this idea for decoding we need to build a data structure to efficiently hold and retrieve letter n-gram counts. A list could work for this purpose but it would be very slow to use. Since we are always counting letters ‘A’ through ‘Z’ we can encode them (using <code>chr</code> and some simple arithmetic) as the numbers 0 through 26 which means that they can be expressed with a 5 bit binary number. Our efficient data-structure will map 5 bit binary numbers to counts.</p>
<p>We create a tree data-structure that is constrained to have a particular height and with leaf nodes that record counts.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Int</span> <span class="dt">Tree</span> <span class="dt">Tree</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre>
<p>Some example trees are here:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">l0 <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">10</span>
l3 <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">3</span>
l1 <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">4</span>
l2 <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">0</span>
t0 <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> l2 l0
t1 <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> l3 l1
t2 <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">2</span> t1 t0</code></pre>
<p>These have been named suggestively to indicate how the tree works. We need to have a constructor</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">initTree n</code></pre>
<p>which outputs a tree for a binary representation with <code>n</code> bits. Include a type signature and a definition for that function. We will also want a getter-function</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">treeCount t w</code></pre>
<p>which given a tree <code>t</code> and a number <code>w</code> returns the tree’s count for <code>w</code>. We also want a setter-function which updates the tree</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">treeInsert t w</code></pre>
<p>which will update the count that tree <code>t</code> has for number <code>w</code>. For both of the functions above write a type signature and recursive definition. A hint for writing them is that the base case (where the tree is just a <code>Leaf Int</code>) is obvious and you should just return the count. Next try to handle the case for a tree formed with one root node and two leaves and think about how the algorithm should recurse Then handle the case where you have two levels and hence four leaves, etc. The definition for each function shouldn’t be longer than five lines. <code>mod</code> and <code>div</code> are your friends here: review them if you don’t know what they do.</p>
<p>You will want to write an interface for this tree that handles the abstraction from character to integer. It is up to you to decide how to handle that abstraction. <code>asciiTreeInsert</code>, for instance, is one way to go. You will also want to generalize to the case where you have multiple characters since we care about n-gram statistcs. Its difficult to make the tree structure handle any particular length of n-gram, so just define a tree for the shorter n-grams and use those to generate counts. You will want to think about the underlying binary representation when doing this.</p>
<h2 id="estimating-the-length-of-the-vigenère-password-extra-credit">Estimating the length of the Vigenère password (Extra Credit)</h2>
<p>The most general problem is where you do not know the length of the password. You will write a third program</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">./vindecode</span> [ciphertext file]</code></pre>
<p>which outputs the password and the plaintext. To get this program to work you will want to use some trick to reduce the search space of possible password lengths or you can just try to brute-force it. To cut down the size of the search space you may want to think about what’s going to happen if the same word appears in the plaintext multiple times in the same location modulo the password length (i.e. same place relative to the password). The double hint is that you may want to look at the <code>gcd</code> of the text differences between multiple occurrences.There is noise in calculating the <code>gcd</code> so you’ll want to focus on the <code>gcd</code> of subsets of the repetition periods (and how long the repetition is). The file to decode is here: <a href="../fls/c3.txt">c3.txt</a>.</p>
<h1 id="what-to-turn-in">What to turn in</h1>
<p>You should have written two programs: <code>derot.hs</code> and <code>vindecoden.hs</code> which perform the first two tasks. For the extra-credit task you will turn in <code>vindecode.hs</code>. Grading will be based on whether your files can decode the ciphertexts and whether the code clearly demonstrates how you did it. Save your programs into a folder <code>lab2</code> within your subversion repository.</p>
<p>Your code should also include some code for your n-gram counting functions. Make sure that you have the functions <code>treeInsert</code> and <code>treeCount</code> implemented with the appropriate type signatures.</p>
<p>It is a good idea to try to decode the passages first without restricting yourself to automatic algorithms. The code you hand in does may take a while to decode the passages. If your code is inefficient at performing the decrypting task then you should submit an example demonstrating that your code does work for the simpler example. Make a note in you README file along with your submission to discuss practicality.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
