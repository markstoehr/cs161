--------
title: Lab 5: Using Randomness
--------

# Requirements for the lab:

Download one of these files:

- [RandState.zip](../fls/RandState.zip)
- [RandState.tar.gz](../fls/RandState.tar.gz)

and build off of that source code.  The code turned in
should be able to complete the exercises listed in this
assignment. For each function requested include a comment
above it indicating which exercise in the lab the function corresponds to.
Each function that is asked to be tested should be tested.  A test
looks like this:

```haskell
test5 = f x y z == output
```

where `x`,`y`,`z` are hard-coded inputs and `output` is a known output.
In the case where the test.  The tests, however, are generally
going to be for monadic code which means that testing 
should be written with monadic code. The first exercise is to do
this

Consider the example function included in `stateExample2` and it
is meant to output a random list of a specified length.  Your
first task to to test this:

1. Write a function `testStateExample2` which tests that the list output by `stateExample2` is the correct length. Testing is ultimately about `Bool` types but the function you write should be monadic so you are free to write the type signature to accomodate monadic requirements. The task is to write the appropriate type signature and to construct a function to test.  Put this in a file `rand.hs` where all of the functions will. You will need to use `import` statesments similar to what is in `StateExample.hs`.

Another basic task is to put all the tests together.

2. Write a function `testAll` which will be added to throughout the lab as you add more tests.  It should indicate the number of tests passed. (It could also include output on which tests passed--but that is not a requirement).


# Randomness

 A common requirement for computer programs is that there should be some randomness to the behaviour of the program. For this you need a random number generator, which can generate an unlimited sequence of random numbers. Typically this these numbers are not truly random, but pseudo-random.

A pseudo-random number generator generates a sequence of numbers based on an initial state s using a function f. I.e. the states are s1 = f(s), s2 = f(f(s)), s3 = f(f(f(s))), etc. Each random number is then derived from each of these intermediate states (typically by taking a small proportion of the 0's and 1's from the state).

f has to be chosen so that subsequent states have no obvious correlation, so for most intents and purposes the numbers generated are random, but the sequence of numbers is in fact entirely determined by the initial state s.

In many programming language, the random number generator state is hidden from the programmer, but because of the purity of Haskell, the random number generator state must explicitly be passed through your program. 

 The following ghc session shows how the function random from the System.Random module can be used. 

```haskell
Prelude> import System.Random
Prelude System.Random> :t random
random :: (Random a, RandomGen g) => g -> (a, g)
Prelude System.Random> g <- newStdGen -- create new random number generator
Prelude System.Random> let (x, g') = random g :: (Int, StdGen) 
```

We had to specify the type above so random knows what type to generate

```haskell
Prelude System.Random> x
-4940845671478547204
Prelude System.Random> let (x, _) = random g :: (Int, StdGen)
Prelude System.Random> x 
-4940845671478547204
```

Oops, reusing `g` gives us the same number again

```haskell
Prelude System.Random> let (x, g'') = random g' :: (Int, StdGen)
Prelude System.Random> x 
-7259815437984538120
```

Much better! Using `g'` gives us the next number.

# The State Monad

 The `State` Monad is a fairly general monad that lets you maintain
 state between functions without have to explicitly pass it from one
 function to the next.

This is particularly useful when using random numbers in many parts of
a Haskell program, as otherwise we would have to explicitly pass the
random number generator in and out of every function that needed it.

There is a standard implementation of the `State` monad in a package
called `Control.Monad.State`. However, this isn't available in all
Haskell distributions, and the implementation is rather complex, so we
have provided a simple version of the State monad in the provided file
`UCState.hs`.

`State` is a Monad, so you can use it with do notation. An instance of
the state monad is a function of type `s -> (a, s)`, where `s` is the
type of the state, and `a` is the "real" return type of the
function. The way State is defined, the state portion is implicitly
passed between functions unless explicitly modified. The functions get
and put play a special role, as they allow you to fetch and update the
state. The below example illustrates how these work in a do block.

```haskell
import UCState

type StringState a = State String a

testState :: StringState Int
testState = do
    initState <- get -- Pull out current state
    let newState = "Hello " ++ initState
    put newState -- Replace old state
    return 1 -- this will be the value that is returned along with state
```

`testState` is then a value of type `StringState Int`.

```haskell
[~/TA/cs161/git/labs/labRand]$ ghci StringState.hs UCState.hs
Ok, modules loaded: UCState, Main.
*Main> :t testState
testState :: StringState Int
*Main> testState

:1:0:
    No instance for (Show (StringState Int))
      arising from a use of `print' at :1:0-8
    Possible fix:
      add an instance declaration for (Show (StringState Int))
    In a stmt of an interactive GHCi command: print it
```

We can use `runState` to pull the function out of `State`, and then provide
an initial value for the state to kick it off

```haskell
*Main> :t runState testState
runState testState :: String -> (Int, String)
*Main> runState testState "bob"
(1,"Hello bob")
```

Notice how we effectively get two return values from running the state
monad: the actual returned value, and the final state. Make sure that
you understand how the result above was obtained.

# Lab Tasks

Familiarize yourself with the definition of the function `rand` in
`RandState.hs`. The function `rand` generates numbers in a huge range (what is it?).
 
You can test this function from `ghci` by creating a new random number
generator, and then using the `runRandom` function. E.g.:

```haskell
[~/labRand]$ ghci RandState.hs UCState.hs
Ok, modules loaded: RandState, UCState.
*RandState> gen <- newStdGen -- Create new random number generator
*RandState> runRandom rand gen :: Int
1256390094846286344
*RandState> gen <- newStdGen
*RandState> runRandom rand gen :: Double
0.5556050250436191
```

See `RandState.hs` to see how `runRandom` is impemented.

3. Implement a new function `randR :: Random a => (a, a) -> RandState
a` that is like `rand`, but generates numbers in a specified
range. Use the function `randomR :: RandomGen g => (a, a) -> g -> (a,
g)` in `System.Random`. You can copy and paste the definition of `rand`
from `RandState.hs` as a starting point. Put this in `rand.hs` (as with all the other exercises).

4. Using `randR` implement a function `rollTwoDice` which generates a random
sum of two dice (so between `2` and `12`).  Choose the appropriate type signature.


## Shuffling Cards

In this section we write code to randomly shuffle a deck of cards

```haskell
-- Data types to represent playing cards
data CardValue = King | Queen | Jack | NumberCard Int
    deriving (Show, Eq)
data CardSuit = Hearts | Diamonds | Spades | Clubs
    deriving (Show, Eq)
data PlayingCard = PlayingCard CardSuit CardValue
    deriving (Show, Eq)

{-
 - fullCardDeck will be a deck of cards, 52 in total, with a King, a Queen, 
 - a Jack and NumberCards from 1 to 10 for each suit.
 -}
fullCardDeck :: [PlayingCard]
fullCardDeck = [ PlayingCard s v | s <- allsuits, v <- allvals ] where
        allvals = King : Queen : Jack : [ NumberCard i | i <- [1..10] ]
        allsuits = [Hearts, Diamonds, Spades, Clubs]
```
Typeout the above definitions in your `rand.hs` solution file.

5. Implement a function `removeCard`, which will be monadic. Given a list of Playing Cards, it
should pick a random card out of the list, return the card and the list with the card removed (as a tuple potentially). Test that this functions correctly

This is a basic function that can help you shuffle a deck.  A common interview question is to implement
deck shuffling.  A deck shuffling function should induce a uniform probability distribution over all permutations: i.e.
all orderings of the cards should be equally likely.

6. Implement a function `shuffleDeck` which takes a list of playing cards, `[PlayingCard]`. Test that it returns random permutations.

7. Implement a function `shuffleADeck` which generates and output of a shuffle of 52 cards.

