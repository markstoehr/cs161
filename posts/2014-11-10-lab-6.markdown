--------
title: Lab 6: Using Randomness
--------

# Requirements for the lab:

Download one of these files:

- [RandState.zip](../fls/RandState.zip)
- [RandState.tar.gz](../fls/RandState.tar.gz)

and build off of that source code.  The code turned in
should be able to complete the exercises listed in this
assignment. For each function requested include a comment
above it indicating which exercise in the lab the function corresponds to.  The code should be
Each function that is asked to be tested should be tested.  A test
looks like this:

```haskell
test5 = f x y z == output
```

where `x`,`y`,`z` are hard-coded inputs and `output` is a known output.
In the case where the test.  The tests, however, are generally
going to be for monadic code which means that testing 
should be written with monadic code. The first exercise is to do
this

Consider the example function included in `stateExample2` and it
is meant to output a random list of a specified length.  Your
first task to to test this:

1. Write a function `testStateExample2` which tests that the list output by `stateExample2` is the correct length. Testing is ultimately about `Bool` types but the function you write should be monadic so you are free to write the type signature to accomodate monadic requirements. The task is to write the appropriate type signature and to construct a function to test.  Put this in a file `rand.hs` where all of the functions will. You will need to use `import` statesments similar to what is in `StateExample.hs`.

Another basic task is to put all the tests together.

2. Write a function `testAll` which will be added to throughout the lab as you add more tests.  It should indicate the number of tests passed. (It could also include output on which tests passed--but that is not a requirement).


# Randomness

 A common requirement for computer programs is that there should be some randomness to the behaviour of the program. For this you need a random number generator, which can generate an unlimited sequence of random numbers. Typically this these numbers are not truly random, but pseudo-random.

A pseudo-random number generator generates a sequence of numbers based on an initial state s using a function f. I.e. the states are s1 = f(s), s2 = f(f(s)), s3 = f(f(f(s))), etc. Each random number is then derived from each of these intermediate states (typically by taking a small proportion of the 0's and 1's from the state).

f has to be chosen so that subsequent states have no obvious correlation, so for most intents and purposes the numbers generated are random, but the sequence of numbers is in fact entirely determined by the initial state s.

In many programming language, the random number generator state is hidden from the programmer, but because of the purity of Haskell, the random number generator state must explicitly be passed through your program. 

 The following ghc session shows how the function random from the System.Random module can be used. 

```haskell
Prelude> import System.Random
Prelude System.Random> :t random
random :: (Random a, RandomGen g) => g -> (a, g)
Prelude System.Random> g <- newStdGen -- create new random number generator
Prelude System.Random> let (x, g') = random g :: (Int, StdGen) 
```

We had to specify the type above so random knows what type to generate

```haskell
Prelude System.Random> x
-4940845671478547204
Prelude System.Random> let (x, _) = random g :: (Int, StdGen)
Prelude System.Random> x 
-4940845671478547204
```

Oops, reusing `g` gives us the same number again

```haskell
Prelude System.Random> let (x, g'') = random g' :: (Int, StdGen)
Prelude System.Random> x 
-7259815437984538120
```

Much better! Using `g'` gives us the next number.

# The State Monad

 The `State` Monad is a fairly general monad that lets you maintain
 state between functions without have to explicitly pass it from one
 function to the next.

This is particularly useful when using random numbers in many parts of
a Haskell program, as otherwise we would have to explicitly pass the
random number generator in and out of every function that needed it.

There is a standard implementation of the `State` monad in a package
called `Control.Monad.State`. However, this isn't available in all
Haskell distributions, and the implementation is rather complex, so we
have provided a simple version of the State monad in the provided file
`UCState.hs`.

`State` is a Monad, so you can use it with do notation. An instance of
the state monad is a function of type `s -> (a, s)`, where `s` is the
type of the state, and `a` is the "real" return type of the
function. The way State is defined, the state portion is implicitly
passed between functions unless explicitly modified. The functions get
and put play a special role, as they allow you to fetch and update the
state. The below example illustrates how these work in a do block.

```haskell
import UCState

type StringState a = State String a

testState :: StringState Int
testState = do
    initState <- get -- Pull out current state
    let newState = "Hello " ++ initState
    put newState -- Replace old state
    return 1 -- this will be the value that is returned along with state
```

`testState` is then a value of type `StringState Int`.

```haskell
[~/TA/cs161/git/labs/labRand]$ ghci StringState.hs UCState.hs
Ok, modules loaded: UCState, Main.
*Main> :t testState
testState :: StringState Int
*Main> testState

:1:0:
    No instance for (Show (StringState Int))
      arising from a use of `print' at :1:0-8
    Possible fix:
      add an instance declaration for (Show (StringState Int))
    In a stmt of an interactive GHCi command: print it
```

We can use `runState` to pull the function out of `State`, and then provide
an initial value for the state to kick it off

```haskell
*Main> :t runState testState
runState testState :: String -> (Int, String)
*Main> runState testState "bob"
(1,"Hello bob")
```

Notice how we effectively get two return values from running the state
monad: the actual returned value, and the final state. Make sure that
you understand how the result above was obtained.

# Lab Tasks

Familiarize yourself with the definition of the function `rand` in
`RandState.hs`. The function `rand` generates numbers in a huge range (what is it?).
 
You can test this function from `ghci` by creating a new random number
generator, and then using the `runRandom` function. E.g.:

```haskell
[~/labRand]$ ghci RandState.hs UCState.hs
Ok, modules loaded: RandState, UCState.
*RandState> gen <- newStdGen -- Create new random number generator
*RandState> runRandom rand gen :: Int
1256390094846286344
*RandState> gen <- newStdGen
*RandState> runRandom rand gen :: Double
0.5556050250436191
```

See `RandState.hs` to see how `runRandom` is impemented.

3. Implement a new function `randR :: Random a => (a, a) -> RandState
a` that is like `rand`, but generates numbers in a specified
range. Use the function `randomR :: RandomGen g => (a, a) -> g -> (a,
g)` in `System.Random`. You can copy and paste the definition of `rand`
from `RandState.hs` as a starting point. Put this in `rand.hs` (as with all the other exercises).  Include a test that the function outputs within the specified range.

4. Using `randR` implement a function `rollTwoDice` which generates a random
sum of two dice (so between `2` and `12`).  Choose the appropriate type signature.  Include a test to show that it outputs the right proportions (you will want to run the function multiple times).  The right proportions here means that the empirical frequencies of the dice rolls should match the predicted distribution.  Testing this requires computing probabilities of dice rolls.


## Shuffling Cards

In this section we write code to randomly shuffle a deck of cards

```haskell
-- Data types to represent playing cards
data CardValue = King | Queen | Jack | NumberCard Int
    deriving (Show, Eq)
data CardSuit = Hearts | Diamonds | Spades | Clubs
    deriving (Show, Eq)
data PlayingCard = PlayingCard CardSuit CardValue
    deriving (Show, Eq)

{-
 - fullCardDeck will be a deck of cards, 52 in total, with a King, a Queen, 
 - a Jack and NumberCards from 1 to 10 for each suit.
 -}
fullCardDeck :: [PlayingCard]
fullCardDeck = [ PlayingCard s v | s <- allsuits, v <- allvals ] where
        allvals = King : Queen : Jack : [ NumberCard i | i <- [1..10] ]
        allsuits = [Hearts, Diamonds, Spades, Clubs]
```
Typeout the above definitions in your `rand.hs` solution file.

5. Implement a function `removeCard`, which will be monadic. Given a list of Playing Cards, it
should pick a random card out of the list, return the card and the list with the card removed (as a tuple potentially). Test that this functions correctly

This is a basic function that can help you shuffle a deck.  A common interview question is to implement
deck shuffling.  A deck shuffling function should induce a uniform probability distribution over all permutations: i.e.
all orderings of the cards should be equally likely.  You will want
to write this recursively, handling the base case for an empty deck,
and then using an inductive step: using `removeCard` and then recursing.

6. Implement a function `shuffleDeck` which takes a list of playing cards, `[PlayingCard]`. Test that it returns random permutations.

7. Implement a function `shuffleADeck` which generates and output of a shuffle of 52 cards. Test that it outputs that many cards.

## Extra Credit: Approximating Pi

 We will shift gears a bit in this final part of the lab to show another application of randomness. Randomness can be a powerful tool if we want to work out approximate solutions to problems. There is a general class of computational methods called Monte-Carlo methods that are widely used.

One simple example of a problem that can be solved with a Monte-Carlo method is calculating the approximate value of π. 

Look to the right at the diagram of a circle circumscribed in a square. <img src="../fls/pi-montecarlo.png" style="float: right; margin: 10px"> 
Note that
the ratio of the area of the circle to the square is `(π * 12)/(22) =
π/4`. If we then choose points at random in the square (ie. with `x` and
`y` values in the interval `[-1, 1]`), then we can approximate π by
checking which proportion fall within the circle. The more points are
randomly chosen, the closer the ratio with converge to `π/4`. You can
easily check to see if the point is within the circle - less than `1`
unit away from `(0,0)`.

Here is a template for the pi approximation code:
```haskell
-- Succeed if randomly chosen point from square is inside circumscribed circle 
piTrial :: RandState Bool

-- Perform n trials of the RandState function provided as the second argument,
--  and give back the number of successful trials
-- Hint: To perform the n trials, you can either use sequence from 
--       Control.Monad, or you can use recursion 
bernoulliTrials :: Int -> RandState Bool -> RandState Int

-- Approximate pi using n randomly chosen points
-- Hint: You will probably need to use the fromIntegral function to
--       convert Int into Double.
approxPi :: Int -> RandState Double
```

`approxPi` should be implemented so that we can have the following interactive session

```haskell
> g <- newStdGen
> runRandom (approxPi 10000) g
3.1588
```

8. Implement `approxPi` as above.  Implement `approxPiIO` that makes it available for input and output.  Implement a test that shows that the output expression, indeed, is an approximation of `π`

# What to Submit



