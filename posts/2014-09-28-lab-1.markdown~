---
title: Lab 1: The Install Party
---

The main purpose of this lab is to get you setup with Haskell so that you
may begin coding and working on projects.  
<a href="http://xkcd.com/1312/"><img src="http://imgs.xkcd.com/comics/haskell.png" style="float: right; margin: 10px;" title="The problem with Haskell is that it&#39;s a language built on lazy evaluation and nobody&#39;s actually called for it." /></a>

To get up and running with Haskell you can run

    ghci

and try some basic commands:

    Prelude> 2 + 2
    4
    Prelude> 8 ^ 10
    1073741824

This class will primarily focus and support development of your Haskell 
programs on the provided lab comptuer setup.  People working with other setups is not supported
but can be used to submit assignments.

# Assignment Submission

At present the <a href="http://git-scm.com/">git</a> repository for 
the class has not been setup yet, and we apologize for this.  We will be setting this up as soon as possible.  Until git is setup all submissions will be done via email.  There is no submission for this lab.

Submissions are due on Wednesday before midnight.  A precise definition can be given in terms of time-stamps.  Any submission will include a time-stamp (we will address this later) and that time-stamp
must correspond to a time *before* `2014-mm-dd 00:00:00.0 UTC`
where `mm-dd` corresponds to the Thursday following the lab session.  This will give you approximately two days to complete the lab.
You will have at hour disposal two 24-hour extensions at your disposal for the quarter. You may use them both for two labs or you may use one on two separate labs.  Other extensions are generally not granted.

# Git

Submissions will be done with Git

# Haskell Language Specification

At 329 pages the [language report for Haskell](http://www.haskell.org/definition/haskell2010.pdf)
 is relatively short compared to [Java](http://psc.informatik.uni-jena.de/languages/Java/javaspec-3.pdf)
at 684 pages or [C](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf) 550 pages.  Of course it does not
approach the elegant simplicity of [Scheme](http://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r5rs.ps) which
is specified in roughly 50 pages.  The language report for Haskell is quite readable and making your way through a couple of chapters
each week will give you a great deal more insight into the language.  Looking at the [code for commonly used modules](http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-List.html) such as `Data.List` is also very helpful.  Search
for "Haskell Live Coding" on [YouTube](http://www.youtube.com) to get a sense of how people write Haskell.  
Taking some time to record yourself coding can also be very useful as you develop as a programmer.

# Text Editors

In order to develop on the GNU/Linux machines you will want to pick
a good text editor. My preference is `emacs` but there are many
other choices the most prominent being `vim`.  There is a long
history of debate about which is the better editor.

Both of these editors are open source,
highly configurable, have large development communities,
and have a low memory foot print.  They are both commonly used in Google.
[Emacs](http://www.emacswiki.org/emacs/) strength relative to vim in a Haskell development
context is its support for [REPL](en.wikipedia.org/wiki/Read–eval–print_loop)
or Read-Eval-Print-Loop which allows you to execute small chunks of code at a time.

Should you choose to use Emacs you will use the `ctrl` key quite often
which will mean that that you will likely want to make the Caps Lock key 
another `ctrl` since Caps Lock is not very useful. On Mac OS you can configure
your terminal preferences to "option as meta" and Keyboard Preferences to swap
the option and command keys, and set Caps Lock to Control.  

Using Emacs takes some practice and you are well advised to use the tutorial
on the welcome screen.  Many Emacs users opt to configure emacs using a configuration
file stored in `~/.emacsrc` which is the [Emacs Init File](http://www.emacswiki.org/InitFile).
A list of useful Emacs commands can be found in the [reference cards here](http://www.gnu.org/software/emacs/refcards/).

# Basic Commands

Working on the unix machines will require some familiarity with the 
terminal and the commands.  The terminal can be accessed on Ubuntu 
desktop systems via `ctlr+alt+t`.

A great reference for navigating the command line is [here](http://cli.learncodethehardway.org/bash_cheat_sheet.pdf)
which is based on an [excellent command line book](http://cli.learncodethehardway.org/book/).

# SSH

The basic workhorse of remote sessions for GNU/Linux is `ssh`.  The general usage is

    ssh username@computername.cs.uchicago.edu

and then you will be prompted for a password.  One way to make the connection more secure
and remove the need for typing in a password each time is to use `ssh-keygen`.
In your local machine run

    mkdir ~/.ssh      # make a directory to store your ssh profile
    chmod 700 ~/.ssh  # set the permissions
    ssh-keygen -t rsa

(note that `#` begins a comment so everything past it is ignored)
and you will create an ssh public key in `~/.ssh/id_rsa.pub` and identification in `~/.ssh/id_rsa`.
Some users don't use a passphrase but doing so always provides better security.  The passphrase itself
is never transmitted over the internet.  You then create a copy of the authorized key on the remote
computer

    ssh-copy-id user@computername.cs.uchicago.edu

and then you should be able to `ssh` into any of the University of Chicago machines without entering
in your password each time.  More details are [here](https://help.ubuntu.com/community/SSH/OpenSSH/Keys)
and [here](https://help.github.com/articles/generating-ssh-keys).

# Screen 

`screen` is a window manager that can be used through an `ssh` tunnel.  I found
[this](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-screen-on-an-ubuntu-cloud-server)
to be a reasonably good tutorial.  The main point is that you may want to have several emacs sessions running concurrently
in your ssh tunnel and Screen makes that possible.  Open a screen session

    screen -S cs161

to return to a previous screen

    screen -r cs161

and to list the screens

    screen -list

The linked tutorial above explains many of the key commands.  The most important is
`ctrl-a d` which detachs the current screen.  There are also commands to open tabs,
switch between them, scroll in a screen, and to customize screen using
a `~/.screenrc` file.  An example `~/.screenrc` file is [here](https://gist.github.com/ChrisWills/1337178)
