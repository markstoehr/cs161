--------
title: Lab 4: Haskell Calculator
--------

# Notes on Recursion

Recursive solutions to a problem begin by solving a trivial 
_base case_ and then solving the _recursion step_.
Take, for instance, summation over a list.  The _base case_ is

```haskell
listSum [] = 0
```

and the _recursion step_ is 

```haskell
listSum (x:xs) = x + (listSum xs)
```

which takes a problem and reduces it to one or more simpler cases
of the problem. In the case of list-sum the simpler case
is a summation over the tail of a list.


# Building a Simple Haskell Calculator

Later in the course you will consider monadic parsing but in this lab
we will focus on the simple parsing problem of constructing a calculator.

The calculator should work as follows:
```haskell

> 1 + 1
2
> 2 * 6
12
> (1 + 3) * (5 + 1)
24
> (1 + 2 + 3 * 2 + 6)
15
> (1 + (2 + ((4 + 2) * 6)))
39
> 5 +-6    --This should be parsed as 5 + (-6)
-1
```
where user-input is indicated by a prepended `>`.  The lab consists of:

- Create a data type `ArithExpr` to represent an expression
- Implement a function `eval` to evaluate the expression to a number
- Implement a fuction `simpleParseExpr` to parse a string into an expression
- Use the functions above to read user input and using `fmap` parse the string into an integer and return the result

## Defining the `ArithExpr` Data Type

This data type should represent

- a constructor `Number` for positive or negative integers
- Addition and Multiplication operators represented by the constructors `Plus` and `Mult`. These operators are most easily defined as a data constructor taking two arguments.

## Evaluating `ArithExpr`

Write a function `eval` which evaluates an `ArithExpr` and outputs a number:

```haskell
> eval (Mult (Plus (Number 2) (Number 3)) (Plus (Number 3) (Number 2)))
25 
```

Recursion is your main tool here.

## Parsing an `ArithExpr` from a string

The input will be whitespace, `*`, `+`, or digits `[0-9]`. To parse
the input the following steps are recommended:

1. Remove whitespace using `isSpace` from `Data.Char`.
2. Tokenize: break up the expression into tokens where each token is an integer (positive or negative), a plus, or a times. You will likely want to perform this operation recursively. The functions `dropWhile`, `takeWhile`, and `span` in `Data.List` will probably be helpful. `Data.Char` has `isDigit` which can also be helpful.  These tokens will be in a list
3. Turn the tokens into an `ArithExpr`.  Here `read` is useful when applied to integers.  Thinking about arithmetic it makes sense to split the list at the operator of least precedence and then recurse on the elements.

### Tokens to `ArithExpr`

Expanding on the third step a little more: think about the expression `4*3+4` which should be broken
up into `4*3`, `+`, `4`. The function `break` will be useful for this.  I called my function that does this
`buildExpr` and in the above example `buildExpr` would be recursively applied so you would get `buildExpr ['4','*','3']`.
Use
```haskell
error "Informative Error Message"
```
as the result of functions that end up with a parsing error (i.e. an ill-formed input).  The error message should be replaced with something
informative.

## User Input

User input can be very simple: prompt the user to input a string, take that string, apply 
`simpleParseExpr` to the string, and then output the result.  There's a wrinkle that is added
by the presence of IO.  The hint is to take a standard program for reading in a string and outputing the text.
Consider `getLine`:

```haskell
*Main> :t getLine
getLine :: IO String
```

so `getLine` has type `IO String`.  `simpleParseExpr` will have type signature `String -> Int` so it cannot naively be used.  
To use `simpleParseExpr` in a
`do` block you will most likely want to use `fmap` and `show` (think about the exposition on types and functors in class).  
The solution should be not add to the line count of a simple program that prompts the user for input and then prints it out.



## Extra-Credit

Add support for parentheses.  They should be used in the normal way: in that they should form a separate `buildExpr` token
that get parsed separately from the rest of the expression.  The rules for parentheses are important here.

# What to turn in

The work should be saved to a `lab4` folder and there should be a file `lab4.hs` which, when run, should prompt the user for input
and then parse the arithmetic expression.  The stated data structures and functions
 in the exposition above should be included in `lab4.hs`.