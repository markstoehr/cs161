--------
title: Lab 9: Mancala AI
--------

For the final lab we are going to build a simple computer Mancala system
using a simple look-ahead strategy.

Start with the following files: [Mancala.hs](../fls/Mancala.hs), [MancalaBoard.hs](../fls/MancalaBoard.hs), and [MancalaAI.hs](../fls/MancalaAI.hs).  These provide an essentially complete solution to last week's lab, and more: Mancala.hs assumes PlayerB is the computer\
 player, and has been modified accordingly.  We've provided you with the simplest possible AI in MancalaAI.hs.  

You should write all code related to the AI in MancalaAI.hs.  You may modify this file however you like, but you may not modify the module declaration; in particular, the only function this module provides should be `aiNextMove` (which you should modify). If you want to get your AI working with your code from last week (instead of the code we've provided above), that's great, but please do it __after having written your AI__.  We provided you with the above code so that you could focus this week on writing the AI.

## Writing the AI

Today we're going to start with a basic "tree lookahead" AI.  At the base of this is a heuristic score, which is something you get to make up.
  The idea of a heuristic score is that it is a number that is very easy to compute given a MancalaBoard, which roughly says how well a given
player is doing.  The heuristic score might have a signature something like this: 

```haskell
heuristicScore :: Player -> MancalaBoard -> Int 
```
Usually heuristic scores are very simple.  Some reasonable approaches might be to have the heuristic score be: 

- The number of stones in the player's store 
- The player's score (number of stones in their store plus number of stones in their pits)  
- The player's score minus the opponent's score

one of the main features

Think of the heuristic score as a "depth 0" tree lookahead: it
evaluates how well the player is doing without looking ahead any
moves.  In a sense this is the base case of the lookahead recursion.
In other words, depth 0 lookahead simply consider all available moves
and takes the move resulting in the best heuristic score.  
which can be compiled from a `playMancala.hs` file.  

Think of the heuristic score as a "depth 0" tree lookahead: it
evaluates how well the player is doing without looking ahead any
moves.  In a sense this is the base case of the lookahead recursion.
In other words, depth 0 lookahead simply consider all available moves
and takes the move resulting in the best heuristic score.


Depth `d` lookahead considers all available moves, and takes the move
resulting in the best position.  Now, instead of determining the best
position simply by applying the heuristic score, the best position is
determined by looing ahead d moves.  That is, for each available move,
it uses lookahead of depth d-1 to determine what the _next_
move would be, and then evaluates that move with depth `d-1` lookahead.

There are many ways to organize this code, but I found the following
organization useful.  If this doesn't make sense to you, or you want
to organize your code differently, please do!  This is just a little
something to get you started.

```haskell
aiNextMove :: MancalaBoard -> Move
aiNextMove mancala = lookahead mancala 0 -- slowly increase the depth

evalPosition :: Player -> MancalaBoard -> Int -> Int
evalPosition player mancala 0     = -- heuristic score goes here
evalPosition player mancala depth = -- recursive call, based on depth d-1 lookahead, goes here

lookahead :: MancalaBoard -> Int -> Move
lookahead mancala depth = -- uses evalPosition at the same depth to determine the next move to make
```

## Extending your AI

In addition to choosing a good heuristic function, you can "hard code"
some moves.  For example, if there are k stones in the k-th pit from
your store, picking up that pit guarantees that the last stone lands
in your store and you get an extra move.  (This is not always the best
move, but it may help to take this into account.)  And there are many
other clever things you can do.


Note that, once you hard code some moves like this, you are
essentially forcing those moves.  This means that you may be able to
increase the depth of your lookahead without it taking too long.

## Compiling Your Program

You may want to compile your code to make it run faster.  Compiling
multi-file programs with ghc is a little bit involved.  The following
sequence of commands should do the job.

```bash
stoehr@feverfew:~/TA/cs161/labs/lab9$ ghc -c MancalaBoard.hs 
stoehr@feverfew:~/TA/cs161/labs/lab9$ ghc -c MancalaAI.hs 
stoehr@feverfew:~/TA/cs161/labs/lab9$ ghc -o mancala Mancala2.hs MancalaBoard.hs MancalaAI.hs 
compilation IS NOT required
compilation IS NOT required
stoehr@feverfew:~/TA/cs161/labs/lab9$ ./mancala 
```


Submit an AI implementation as well as a README.  Extra-credit will be granted to well-explained and demonstrated extensions to the basic look-ahead strategy.

