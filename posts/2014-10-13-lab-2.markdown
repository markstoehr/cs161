---
title: Lab 2: Intersections and Computational Geometry
---

# Special Note

This is an extra-credit lab.  The lab due this week is last week's lab.

# Using Haskell as a model for Computational Geometry

The basic idea here is to use Haskell's algebraic data types as a basis for
defining geometric objects. Analytic geometry can then be used to 
answer geometric questions.  In this lab we will model shapes in the two-dimensional plane
and answer questions about intersection.  This is useful for thinking about the code
underlying computer games.

## Basic Definitions

We begin the lab with some simple definitions

```haskell
-- A point is a point in the xy plane, represented by x and y coordinates
-- E.g. (Point 0.0 0.0) is the origin, (Point (-1) (1)) is in the top left
-- quadrant.
data Point = Point Double Double
    deriving (Show, Eq)

-- A line segment is a straight line of finite length, defined by its
-- two end points.   E.g. (LineSegment (Point 0 0) (Point 1 1)) is a
-- line segment from the origin to the coordinate (1, 1)
data LineSegment = LineSegment Point Point 
    deriving (Show, Eq)


-- A Path is a 2D path in the xy-plane.  The idea is that Path can be 
-- extended to support straight lines, curves, and arbitrary paths, 
-- but currently there is only one data constructor for Path: Line.
data Path = 
-- Line represents an infinite straight line defined by its slope a
-- and its y intercept b, ie. by the equation y = ax + b
    Line Double Double
    deriving (Show, Eq)
```

So we now have some basic data structures.  LineSegments are constructed from points
and we have an abstract notion of a path formed from a line.  Throughout this
lab we are going to expand the definition of `Path` to include more definitions 
and we will write functions that use path using Haskell's pattern-matching facilities
to get the definition right (NOTE: when writing a function that maps a `Path` to something else
use pattern matching idioms).  

1. Write a function `intersects` that checks whether a `LineSegment` intersects with a `Line`.  Try solving for the problem in the case where the line segment is vertical and then see if you can generalize from that.

This first problem is meant as a warm-up to start checking intersections.  We will add to the definition of
`intersect` as we expand the definition of `Path`.

## Defining data types for shapes

A crucial skill is being able to define abstract type definitions to capture real-world objects.  We are wanting to 
do computational geometry so you will need to define models of shapes.

2. Define a type `Shape` that can be a `Triangle`, `Quadrilateral`, or a `Circle`.  Use algebraic datatypes. Make sure that you can check equality and use `Show`.

## Bounding Boxes for Shapes

For any shape there is a unique _minimum_ _bounding_ _rectangle_ which is defined as the smallest axis-aligned rectangle
that encloses the shape.  Axis-aligned here means that each of the four edges of the rectable runs parallel to either the $x$-axis
or the $y$-axis.  Minimum bounding rectangles are very useful for programming computer games because testing for intersections in 
general is a very hard problem.

3. Write a datatype for `BoundingBox`. You may choose how you want to do it, but I suggest defining it by two points: the bottom left corner and the upper-right corner.

4. Write a function `boundShape` which maps a `Shape` to a `BoundingBox` that maps a shape to its minimum bounding rectangle. Functions such as `min`, `minimum`, `max`, `maximum` may be useful here.

5. Write some tests to ensure that your code works.


## Checking if Lines Intersect with bounding boxes

6. Implement a function `intersectsBB` that, given a `BoundingBox`
and a `Path` checks to see if the path intersects the bounding box.  At present this only includes a `Line`

7. Write a function `mightIntersectShape` which use the functions already present to check if a path intersects the bounding box of a shape.  This should be a short function without much innovation to it.

8. Extend Path to include a type constructor `Parabola` and add onto `intersects` and `intersectsBB`.





