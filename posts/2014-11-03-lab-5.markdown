--------
title: Lab 5: More Haskell Calculators
--------


We shall additionally be adding in
rational numbers.  An input expression might look like:

```haskell
> 1/9 + -7/-8 * -51/33
```

1. Design a data type similar to `ArithExpr` which has a rational numbers.  Call it `RArithExpr`, include the possibility of having integers.

In order to work with rational expressions you'll need to be able to
read them in.  There are many ways to write the same rational
number since 
<center> $$\frac{a}{b} = \frac{ka}{kb}$$  </center>
so in reading you'll likely want to ensure that you use the smallest
base.  There is a very old, efficient algorithm for computing the base of a fraction in lowest terms that follows from the observations:

- For a positive fraction $$\frac{a}{b}$$ there is a unique integer $q$ such that $b=q\cdot a +r$ where $0\leq r < b$
- If another integer $k$ divides $a$ and divides $b$ then $k$ divides $b-q\cdot a =r$.

The trick is to use recursion.

2. Implement a recursive algorithm to take two integers and create a fraction in lowest terms from those two integers.  Using that function create a parser that accepts a string of the form "91/14" or "107/-31" or "-22/3" and outputs an `RArithExpr`.

## Arithmetic with rational numbers

Adding rational numbers requires thinking about the bases of the
two rational numbers again.  In particular when adding $$ \frac{a}{b} + \frac{c}{d} $$ the base of the result will be the least common multiple of $b$ and $d$.  Fortunately, with a small tweak this can be computed using the function designed in exercise 3.

3. Implement a function for adding rational numbers together that preserves their being in lowest form. Add a test to ensure that your function works correctly.

Multipling rational numbers is straightforward:

4.  Implement multiplication for rational numbers and add in a test that it works.

## Including Variables

We will now use applicative functors to handle variables. We construct
a type `VRArithExpr` which will also allow variables.

5. Implement `VRArithExpr` to include variables.  Variables need to be able to be added and multiplied together.  The basic data associated with a variable should be a string for the variable name.

We need to be able to parse a string into variables.  This will
require some cleverness with `takeWhile` and `dropWhile`.

6. Write a function to parse strings similar to "7/8 * x" into `VRArithExpr`.  We do not allow division to directly take place on variables.

## Implementing Collect

If we want to display the expressions in a succinct manner. We
need an operator that will put like terms with like terms so we
don't display "3*x + 5*x" but rather "15*x".

7. Implement a `collect` function which takes `VRArithExpr` and outputs a `PolyExpr` where `PolyExpr` is a data structure that represents an expression with variables in lowest terms so that all you have are variables, their coefficients, their powers, and the constant term.  It is up to you to design this expression.  Doing so will require another algebraic data type but you can often implement things using the original `eval` function.

Once you have a `collect` expression you should be able to pretty-print the input expression.  Pretty-print here means showing the polynomial expanded into individual terms (no need to worry about factorization).  So something like this:
`2x+5/3*y^2 + x*y`.

8. Print the expression back to the user in a pretty-print form.  Include some tests that this works.

## Extra Credit

9. Make all of the above work but with parentheses.

## What to turn in

This lab should be saved to a `lab5` folder with a `README` and a `lab5.hs`.